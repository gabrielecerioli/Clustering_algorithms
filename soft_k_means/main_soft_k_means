import pandas as pd
import numpy as np
beta=1 #STIFFNESS
# Loading and trasforming into a numpy matrix the dataset
df=pd.read_csv('Iris.csv')
selected_columns = ['SepalLengthCm', 'SepalWidthCm', 'PetalLengthCm', 'PetalWidthCm']
data_matrix = df[selected_columns].to_numpy()
print("Data matrix:")
print(data_matrix)
print(f"shape: {data_matrix.shape}")

#Finding the range of the dataset
max_values=df[selected_columns].max()
min_values=df[selected_columns].min()

# Generate initial centroids randomly within the range of the dataset
initial_centroids=np.random.uniform(min_values, max_values, (3,4))
print("Initial centroids:")
print(initial_centroids)

# Euclidean distance function
def d(a,b):
    return np.sqrt(np.sum((a-b)**2))
# First assignment
responsibilities=np.zeros((data_matrix.shape[0],3))
for i in range(data_matrix.shape[0]):
    distances = np.array([d(data_matrix[i], centroid) for centroid in initial_centroids])
    responsibilities[i]=np.exp(-beta*distances)/np.sum(np.exp(-beta*distances))
#print("Initial responsibilities:")
#print(responsibilities)

for k in range(10):
    # Calculating the new centroids
    for j in range(3):
        r_j = responsibilities[:, j] # prendo le colonne della matrice responsibilities
        initial_centroids[j] = np.sum(r_j[:, np.newaxis] * data_matrix, axis=0) / np.sum(r_j)

    # Updating the responsibilities with the new centroids
    for i in range(data_matrix.shape[0]):
        distances = np.array([d(data_matrix[i], centroid) for centroid in initial_centroids])
        responsibilities[i]=np.exp(-beta*distances)/np.sum(np.exp(-beta*distances))

print(np.sum(responsibilities[:, 0]))
print(np.sum(responsibilities[:, 1]))
print(np.sum(responsibilities[:, 2]))
print(responsibilities)